diff --git a/ttf2mesh.c b/ttf2mesh.c
index abf85ec..bf77745 100644
--- a/ttf2mesh.c
+++ b/ttf2mesh.c
@@ -56,6 +56,7 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <signal.h>
+#include <limits.h>
 
 /* Big/little endian definitions */
 #if defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__)
@@ -676,12 +677,19 @@ int parse_simple_glyph(ttf_glyph_t *glyph, int glyph_index, uint8_t *p, int avai
 
     j = 0;
     n = -1;
+    int npoints_remaining = glyph->npoints;
     for (i = 0; i < glyph->ncontours; i++)
     {
         j = (int)big16toh(endPtsOfContours[i]);
-        glyph->outline->cont[i].length = j - n;
+
+        int length = j - n;
+        npoints_remaining -= length;
+        if (length < 0 || npoints_remaining < 0) return TTF_ERR_FMT;
+
+        glyph->outline->cont[i].length = length;
         glyph->outline->cont[i].subglyph_id = glyph_index;
         glyph->outline->cont[i].subglyph_order = 0;
+
         if (i != glyph->ncontours - 1)
             glyph->outline->cont[i + 1].pt = glyph->outline->cont[i].pt + j - n;
         n = j;
@@ -913,6 +921,7 @@ int parse_composite_glyph(ttf_t *ttf, ttf_glyph_t *glyph, uint8_t *p, int avail)
 
     /* initialize outline */
     glyph->outline = allocate_ttf_outline(glyph->ncontours, glyph->npoints);
+    int npoints_remaining = glyph->npoints;
     if (glyph->outline == NULL) return TTF_ERR_NOMEM;
 
     /* initialize other glyph fields */
@@ -985,7 +994,12 @@ int parse_composite_glyph(ttf_t *ttf, ttf_glyph_t *glyph, uint8_t *p, int avail)
         for (i = 0; i < ttf->glyphs[glyphIndex].ncontours; i++)
         {
             glyph->outline->cont[n].pt = curr;
-            glyph->outline->cont[n].length = ttf->glyphs[glyphIndex].outline->cont[i].length;
+
+            int length = ttf->glyphs[glyphIndex].outline->cont[i].length;
+            npoints_remaining -= length;
+            if (length < 0 || npoints_remaining < 0) return TTF_ERR_FMT;
+
+            glyph->outline->cont[n].length = length;
             glyph->outline->cont[n].subglyph_id = glyphIndex;
             glyph->outline->cont[n].subglyph_order = nglyphs;
             for (j = 0; j < glyph->outline->cont[n].length; j++)
@@ -1044,6 +1058,10 @@ int parse_glyf_table(ttf_t *ttf, pps_t *pp)
     {
         offset = pp->ploca16 ? pp->ploca16[i] * 2 : pp->ploca32[i];
         if (offset == pp->sglyf) continue;
+
+        if (offset + (int)sizeof(ttf_glyfh_t) > pp->sglyf)
+            return TTF_ERR_FMT;
+
         hdr = (ttf_glyfh_t *)(pp->pglyf + offset);
         if ((int16_t)big16toh(hdr->numberOfContours) >= 0) continue;
         result = parse_composite_glyph(ttf, ttf->glyphs + i, pp->pglyf + offset, pp->sglyf - offset);
@@ -1151,11 +1169,15 @@ static int ttf_extract_tables(const uint8_t *data, int size, pps_t *s)
     rec = (ttf_tab_rec_t *)(s->hdr + 1);
 
     #define check_tag(str) (*(uint32_t *)rec->tableTag != *(uint32_t *)str)
-    #define match(type, name, str) \
+    #define match(type, name, str)                      \
     if (*(uint32_t *)rec->tableTag == *(uint32_t *)str) \
-    { \
-        s->s##name = rec->length; \
-        s->p##name = (type)(data + rec->offset); \
+    {                                                   \
+        s->s##name = rec->length;                       \
+        s->p##name = (type)(data + rec->offset);        \
+        if (rec->offset > INT_MAX - rec->length)        \
+            return TTF_ERR_FMT;                         \
+        if (rec->offset + rec->length > (unsigned)size) \
+            return TTF_ERR_FMT;                         \
     }
 
     while (ntab--)
@@ -1163,6 +1185,7 @@ static int ttf_extract_tables(const uint8_t *data, int size, pps_t *s)
         conv32(rec->checkSum);
         conv32(rec->offset);
         conv32(rec->length);
+        if (rec->offset > INT_MAX - rec->length) return TTF_ERR_FMT;
         if (rec->offset + rec->length > (unsigned)size) return TTF_ERR_FMT;
         if (check_tag("head"))
             if (ttf_checksum(data + rec->offset, rec->length) != rec->checkSum)
@@ -1314,7 +1337,7 @@ static int locate_fmt4_table(pps_t *s)
     for (i = 0; i < ntab; i++)
     {
         int offset = big32toh(s->pcmap->encRecs[i].offset);
-        if (offset + 4 > s->scmap) return TTF_ERR_FMT;
+        if (offset + 4 > s->scmap || offset < 0) return TTF_ERR_FMT;
         uint16_t format = *(uint16_t *)((char *)s->pcmap + offset);
         if (big16toh(format) != 4) continue;
         s->pfmt4 = (ttf_fmt4_t *)((char *)s->pcmap + offset);
